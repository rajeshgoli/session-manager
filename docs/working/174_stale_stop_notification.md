# Issue #174: Stop Notification Replays Stale Message After Context Clear

**Ticket**: rajeshgoli/session-manager#174
**Status**: Investigation complete, awaiting implementation

---

## Problem Statement

After `sm clear <agent>` + `sm send <agent> "new task" --urgent`, the stop notification sent to the caller contains the agent's **last message from before the clear**, not the response to the new task.

**Observed format:**
```
[sm] agent-name stopped:
<message from task A, before clear>
```

**Expected format:**
```
[sm] agent-name stopped:
<message from task B, the new task>
```

This caused the EM to misread the agent as "still stuck" and clear it mid-work, destroying active context.

---

## Root Cause Analysis

### Background: how stop notifications work

When `sm send ... --urgent` (or any mode with `notify_on_stop=True`) delivers a message:

1. The message is delivered to the target session
2. `state.stop_notify_sender_id = sender_id` is stored in `SessionDeliveryState` (in-memory)
3. When the target's Stop hook fires, `mark_session_idle(session_id)` is called
4. `mark_session_idle()` sees `stop_notify_sender_id` is set and calls `_send_stop_notification()`
5. `_send_stop_notification()` reads `session_manager.hook_output_store.get(session_id)` to get the last output
6. The notification is sent with that output

`hook_output_store` is `app.state.last_claude_output` — a shared dict populated by the hook handler **whenever `last_message` is present**, before Stop/Notification event-specific branching (`src/server.py:1350-1358`, before the `hook_event == "Stop"` branch at line 1362).

### How `sm clear` resets state (the #167 fix)

`_invalidate_session_cache()` (added for #167) clears:
- `app.state.last_claude_output[session_id]` — removes cached output
- `app.state.pending_stop_notifications` — removes deferred notification flag
- `state.stop_notify_sender_id` — clears any pending notification recipient

`cmd_clear` calls `client.invalidate_cache(session_id)` **after a 2-second sleep** following the tmux `/clear` command.

### The gating bug: hook-agnostic consumption of `stop_notify_sender_id`

The root cause is **not** primarily cache staleness — it is that `mark_session_idle()` is completely hook-agnostic. Any Stop hook that fires while `stop_notify_sender_id` is set will unconditionally consume it and send a notification (lines 275-283 of `src/message_queue.py`). There is no correlation between when `notify_on_stop` is armed (by `sm send --urgent`) and which Stop hook invocation is entitled to consume it.

Cache staleness is a secondary symptom: it determines what message content X appears in the notification, but the fundamental failure is that the wrong Stop hook event (from `/clear`) fires the notification at all. Even if the cache were bypassed entirely, the `/clear` Stop hook would still steal `stop_notify_sender_id` and prevent task B's notification from firing.

The fix must establish correlation — a mechanism that allows the arm event (`sm send --urgent` / `invalidate_cache()`) to specify which Stop hook is the intended consumer.

### The race condition (why #167 fix is incomplete)

`cmd_clear` assumes the Stop hook generated by Claude processing `/clear` arrives at the server **within 2 seconds** of sending Enter. If it does, the sequence is:

```
T=0    Enter sent to Claude via tmux
T~1s   Claude processes /clear, fires Stop hook → HTTP request sent to server
T~1s   Server: last_claude_output[id] = X  (re-reads old transcript, finds task A message)
T~1s   Server: mark_session_idle() → stop_notify_sender_id=None → no notification (correct)
T=3.5s cmd_clear: invalidate_cache() → clears X ✓
T=3.5s cmd_clear returns
T=3.5s+ caller: sm send --urgent → stop_notify_sender_id = EM
T=later task B Stop hook → sends notification with Y ✓
```

**But this fails when the `/clear` Stop hook arrives LATE** — after `invalidate_cache()` has already run AND after `sm send --urgent` has set `stop_notify_sender_id`:

```
T=0    Enter sent to Claude via tmux
T=3.5s cmd_clear: invalidate_cache() → clears X ✓ (stop_notify_sender_id=None at this point)
T=3.5s cmd_clear returns
T=3.5s+ caller: sm send --urgent → stop_notify_sender_id = EM   ← race window opens
T=3.6s  LATE Stop hook from /clear arrives at server:
           read_transcript() → last_message = X   (old transcript still has task A message!)
           last_claude_output[id] = X             ← X re-stored!
           mark_session_idle():
             stop_notify_sender_id = EM           ← set by sm send --urgent
             _send_stop_notification() fires:
               hook_output_store.get(id) = X      ← stale!
               notification: "[sm] agent stopped:\n{X}" → sent to EM  ← BUG
             stop_notify_sender_id = None          ← cleared
T=later task B Stop hook fires:
           stop_notify_sender_id = None            ← already cleared
           No notification sent to EM              ← double failure
```

**The race window exists because the 2-second sleep is not a reliable fence.** The late arrival can be caused by:
- Claude taking > 2s to process `/clear` (e.g., if it was mid-response when ESC was sent)
- FastAPI async task scheduling: the `/clear` Stop hook HTTP request is in-flight concurrently with `invalidate_cache()`; if they race and the Stop hook completes AFTER invalidate, X is re-stored
- Server load causing delayed HTTP request processing

### Why the original proposed fix is incomplete

A previous version of this spec proposed passing `last_output` directly from the Stop hook handler to `_send_stop_notification()` (bypassing the cache read). This is a valid and useful change — the notification content would no longer be stale — but it does **not** fix the race condition.

The fundamental problem is that `mark_session_idle()` unconditionally consumes `stop_notify_sender_id` on **any** Stop hook that finds it set (lines 275-283 of `src/message_queue.py`). Passing `last_output` through changes what X the notification contains, but the `/clear` Stop hook still consumes `stop_notify_sender_id` and prevents task B's Stop hook from firing a notification at all.

What's needed is a **correlation mechanism**: a way for `mark_session_idle()` to know that a specific Stop hook invocation should be skipped (because it originated from `/clear`, not from task B completion).

### Verified against code

- `_send_stop_notification()` at `src/message_queue.py:914-960`: reads `hook_output_store.get(recipient_session_id)` — no guard against stale cache
- `mark_session_idle()` at `src/message_queue.py:262-286`: unconditionally reads and clears `stop_notify_sender_id` — no guard against spurious Stop hooks
- `cmd_clear` at `src/cli/commands.py:1716`: `client.invalidate_cache()` is called AFTER the 2s sleep, opening the race window; return value is also **not checked** (silent failure possible)
- Stop hook handler at `src/server.py:1349-1365`: updates `last_claude_output` THEN calls `mark_session_idle()` — correct ordering within a single hook, but does not protect against a late hook consuming a newer sender_id

---

## Proposed Fix

### Core mechanism: `stop_notify_skip_count`

The fix uses a skip counter on `SessionDeliveryState` and reorders the `cmd_clear` operations to arm the counter **before** the `/clear` command reaches Claude.

**Invariant**: `stop_notify_skip_count` tracks how many Stop hook invocations should be absorbed (skipped) before the next legitimate notification is fired. Each `/clear` command contributes one skip. When `mark_session_idle()` fires with `skip_count > 0`, it decrements the counter, preserves `stop_notify_sender_id` intact, and does NOT send a notification. The next Stop hook (from task B) sees `skip_count = 0` and fires normally.

### Trace: race scenario fixed

```
T=0    cmd_clear: invalidate_cache() called FIRST (before tmux ops)
         → skip_count incremented to 1
         → last_claude_output[id] cleared
         → pending_stop_notifications cleared
         → stop_notify_sender_id = None (was None)
T=0+   ESC → /clear → Enter sent to Claude via tmux
T=2s   sleep completes, cmd_clear returns
T=2s+  caller: sm send --urgent → stop_notify_sender_id = EM
T=2.5s LATE Stop hook from /clear arrives:
           last_claude_output[id] = X        (stale content re-stored, but won't be read)
           mark_session_idle(last_output=X):
             skip_count = 1 > 0 → decrement to 0
             preserve stop_notify_sender_id = EM
             SKIP notification ✓
T=later task B Stop hook:
           last_claude_output[id] = Y
           mark_session_idle(last_output=Y):
             skip_count = 0, stop_notify_sender_id = EM
             fire notification with Y ✓
             stop_notify_sender_id = None
```

### Trace: happy path still works

```
T=0    cmd_clear: invalidate_cache() called FIRST
         → skip_count incremented to 1
T=0+   ESC → /clear → Enter sent to Claude via tmux
T=1s   /clear Stop hook arrives (early, before sleep ends):
           mark_session_idle(last_output=X):
             skip_count = 1 > 0 → decrement to 0
             stop_notify_sender_id = None → nothing to preserve
             SKIP notification (correct, no sender armed yet) ✓
T=2s   sleep completes, cmd_clear returns
T=2s+  caller: sm send --urgent → stop_notify_sender_id = EM
T=later task B Stop hook:
           mark_session_idle(last_output=Y):
             skip_count = 0, stop_notify_sender_id = EM → fire notification with Y ✓
```

### Change 1: `SessionDeliveryState` in `src/models.py`

Add a `stop_notify_skip_count` field:

```python
@dataclass
class SessionDeliveryState:
    """Tracks delivery state for a session."""
    session_id: str
    is_idle: bool = False
    last_idle_at: Optional[datetime] = None
    saved_user_input: Optional[str] = None
    pending_user_input: Optional[str] = None
    pending_input_first_seen: Optional[datetime] = None
    stop_notify_sender_id: Optional[str] = None
    stop_notify_sender_name: Optional[str] = None
    stop_notify_skip_count: int = 0            # ← new: absorb /clear Stop hooks
```

### Change 2: `_invalidate_session_cache()` in `src/server.py`

Add `arm_skip: bool = False` parameter. When `True`, unconditionally create-or-get the delivery state and increment `stop_notify_skip_count`. When `False` (default), behavior is unchanged — no skip is armed.

```python
def _invalidate_session_cache(app: FastAPI, session_id: str, arm_skip: bool = False) -> None:
    app.state.last_claude_output.pop(session_id, None)
    app.state.pending_stop_notifications.discard(session_id)
    queue_mgr = (app.state.session_manager.message_queue_manager if app.state.session_manager else None)
    if queue_mgr:
        if arm_skip:
            # Always create state if absent (do not skip the arm just because
            # the session has no prior queue-manager state).
            state = queue_mgr._get_or_create_state(session_id)  # ← fixes state-missing gap
            state.stop_notify_skip_count += 1    # ← arm one skip for the /clear Stop hook
        else:
            # Non-tmux paths (codex-app): only clear existing state; do NOT arm skip.
            state = queue_mgr.delivery_states.get(session_id)
        if state:
            state.stop_notify_sender_id = None
            state.stop_notify_sender_name = None
```

**Why `arm_skip` is conditional on the endpoint, not on the session type:**
Two server endpoints both call `_invalidate_session_cache()`:
- `/sessions/{id}/invalidate-cache` (`src/server.py:984`): called by the tmux `cmd_clear` CLI path — **pass `arm_skip=True`**
- `/sessions/{id}/clear` (`src/server.py:965`): a generic endpoint that routes internally by provider in `session_manager.clear_session()`; in current CLI usage, the codex-app path calls this endpoint. Codex-app clear starts a new agent thread and does NOT emit a dedicated `/clear` Stop hook; the next `mark_session_idle()` call comes from legitimate task completion — **keep default `arm_skip=False`**

The arm/no-arm split is therefore a property of which endpoint is called, not of the session provider type. If a future provider uses `/invalidate-cache`, it would correctly receive skip arming.

Endpoint-level change in `src/server.py`:
```python
# /invalidate-cache endpoint (tmux CLI path — emits a /clear Stop hook):
_invalidate_session_cache(app, session_id, arm_skip=True)   # ← new

# /clear endpoint (generic; in current usage, codex-app — does NOT emit a /clear Stop hook):
_invalidate_session_cache(app, session_id)                  # arm_skip=False (default)
```

Note: use `+= 1` (increment) rather than `= 1` (set) so that two consecutive `sm clear` calls correctly arm skip_count to 2, absorbing two `/clear` Stop hooks.

### Change 3: `mark_session_idle()` in `src/message_queue.py`

Add `last_output` parameter and skip logic:

```python
def mark_session_idle(self, session_id: str, last_output: Optional[str] = None):
    state = self._get_or_create_state(session_id)
    state.is_idle = True
    state.last_idle_at = datetime.now()
    logger.info(f"Session {session_id} marked idle")

    # Absorb stop hooks generated by /clear commands
    if state.stop_notify_skip_count > 0:
        state.stop_notify_skip_count -= 1
        logger.debug(
            f"Session {session_id}: skip_count decremented to {state.stop_notify_skip_count}; "
            f"stop notification deferred (sender_id preserved: {state.stop_notify_sender_id})"
        )
        asyncio.create_task(self._try_deliver_messages(session_id))
        return

    # Send stop notification if a sender is waiting
    if state.stop_notify_sender_id:
        asyncio.create_task(self._send_stop_notification(
            recipient_session_id=session_id,
            sender_session_id=state.stop_notify_sender_id,
            sender_name=state.stop_notify_sender_name,
            last_output=last_output,          # ← pass through directly
        ))
        state.stop_notify_sender_id = None
        state.stop_notify_sender_name = None

    asyncio.create_task(self._try_deliver_messages(session_id))
```

### Change 4: `_send_stop_notification()` in `src/message_queue.py`

Accept `last_output` as a parameter. Remove the cache read (defense-in-depth: even if the wrong hook were to slip through, it would only carry the content of that specific hook invocation, not stale cached content):

```python
async def _send_stop_notification(
    self,
    recipient_session_id: str,
    sender_session_id: str,
    sender_name: Optional[str] = None,
    last_output: Optional[str] = None,   # ← new param, replaces cache read
):
    recipient_session = self.session_manager.get_session(recipient_session_id)
    recipient_name = (
        recipient_session.friendly_name or recipient_session.name or recipient_session_id
        if recipient_session else recipient_session_id
    )

    if last_output:
        truncated = last_output[:500] + "..." if len(last_output) > 500 else last_output
        notification = f"[sm] {recipient_name} stopped:\n{truncated}"
    else:
        notification = f"[sm] {recipient_name} ({recipient_session_id[:8]}) completed (Stop hook fired)"
    ...
```

### Change 5: Stop hook handler in `src/server.py`

Pass `last_message` to `mark_session_idle()`:

```python
if hook_event == "Stop" and session_manager_id:
    queue_mgr = app.state.session_manager.message_queue_manager if app.state.session_manager else None
    if queue_mgr:
        queue_mgr.mark_session_idle(session_manager_id, last_output=last_message)  # ← pass last_message
        asyncio.create_task(queue_mgr._restore_user_input_after_response(session_manager_id))
```

### Change 6: Reorder and fix `cmd_clear` in `src/cli/commands.py`

Move `invalidate_cache()` to BEFORE the tmux operations, so skip_count is armed before the `/clear` Stop hook can fire. Also check the return value:

```python
# NEW: invalidate before sending /clear, so skip_count is set before the Stop hook fires
success, unavailable = client.invalidate_cache(target_session_id)
if not success:
    if unavailable:
        # Server is unreachable — skip fence is NOT armed. The /clear Stop hook may
        # steal stop_notify_sender_id if it arrives after a future sm send --urgent.
        logger.error(
            f"Cache invalidation SKIPPED for {target_session_id}: server unavailable. "
            f"Skip fence not armed — stale stop notification possible if server recovers."
        )
    else:
        # Server responded but the operation failed (e.g., session not found).
        logger.warning(
            f"Cache invalidation failed for {target_session_id}; "
            f"stale output may affect next notification"
        )

# Send ESC + /clear + Enter to Claude (existing tmux operations follow here)
...
# sleep(2) is still needed to let Claude process /clear before new prompt is sent

# REMOVED: the existing invalidate_cache() call at the end of cmd_clear is deleted
```

### Why this fix is correct

- **Skip_count prevents wrong hook from consuming sender_id**: the `/clear` Stop hook is absorbed by the skip counter; `stop_notify_sender_id` is preserved until task B's Stop hook fires
- **State-missing gap closed**: `_get_or_create_state()` always creates state before arming, so the skip is guaranteed even for sessions the queue manager has never seen
- **Non-tmux flows not regressed**: `arm_skip=True` is only passed by the `/invalidate-cache` endpoint (tmux CLI path); the `/clear` endpoint (used by codex-app in current CLI usage) keeps `False`, so skip_count is never armed for flows that don't emit a `/clear` Stop hook
- **Pass-through eliminates stale cache as defense-in-depth**: the notification content comes from the specific Stop hook invocation that triggered it, not a shared cache
- **Both race and happy path work**: traced above — skip_count is armed before `/clear` is sent in both cases
- **Backward compatible**: `hook_output_store` still updated for `/status` and `sm what`; no protocol changes; no database schema changes
- **Consecutive clears handled**: `+= 1` means two consecutive tmux clears set skip_count=2, absorbing two `/clear` Stop hooks correctly

### Known limitation: orphaned skip_count

If `sm clear` is called but Claude never processes the `/clear` command (e.g., process crash before the Stop hook fires), skip_count is incremented but never decremented. The next legitimate task B Stop hook would be incorrectly skipped.

With additive (`+= 1`) semantics, calling `sm clear` again does NOT help: it increments skip_count further rather than draining the orphan, creating a deeper deficit.

Since delivery state is entirely in-memory, a **session manager server restart** is the only guaranteed remediation — all `SessionDeliveryState` instances are destroyed, and skip_count returns to 0 on next access. Alternatively, terminating and recreating the agent session produces a new `session_id` and therefore a fresh delivery state.

This edge case (Claude crash mid-clear) is rare. It does not need to block this fix.

### What about the deferred notification case?

When the transcript isn't flushed at Stop hook time (`last_message = None`):
- `mark_session_idle(session_id, last_output=None)` is called
- If skip_count > 0: absorb the skip as normal (don't send)
- If skip_count = 0 and sender_id set: `_send_stop_notification()` receives `last_output=None` → sends generic "(Stop hook fired)" message

The deferred `idle_prompt` path (`server.py:1570-1595`) does NOT call `mark_session_idle()`, so it does not re-send the stop notification. The EM receives a generic message instead of the full content.

This is acceptable: the deferred case is already a degraded path (transcript not flushed is an edge case), and the generic message is at least correct (not stale). If fuller deferred coverage is needed, that's a separate issue.

---

## Acceptance Criteria

1. **Repro scenario fixed**: After `sm clear` + `sm send --urgent`, the stop notification sent to the EM contains the agent's response to the new task (or the generic "Stop hook fired" message), NOT a message from before the clear

2. **Regression for #167 still passes**: existing tests in `tests/regression/test_issue_167_clear_stale_stop_notification.py` continue to pass

3. **New regression test**: A new test in `tests/regression/` simulates the exact race scenario end-to-end:
   - Call `_invalidate_session_cache(app, session_id, arm_skip=True)` → verifies skip_count becomes 1
   - Arm `stop_notify_sender_id = "em-parent"` (simulating `sm send --urgent`)
   - Call `mark_session_idle(session_id, last_output="stale X")` (simulating the late `/clear` Stop hook) → verifies:
     - No notification was sent
     - `stop_notify_sender_id` is still `"em-parent"` (not consumed)
     - skip_count is now 0
   - Call `mark_session_idle(session_id, last_output="task B response Y")` (simulating task B Stop hook) → verifies:
     - Notification IS sent with `"task B response Y"`
     - `stop_notify_sender_id` is cleared

4. **skip_count does not affect sessions with no pending notification**: When `mark_session_idle()` fires with skip_count > 0 but `stop_notify_sender_id = None`, skip_count is still decremented (the skip slot is consumed), and no spurious notification is sent

5. **`arm_skip` path isolation** (regression for non-tmux flow safety):
   - Calling `_invalidate_session_cache(app, session_id, arm_skip=False)` (e.g., the `/clear` endpoint used by codex-app) does NOT increment `stop_notify_skip_count`
   - Calling `_invalidate_session_cache(app, session_id, arm_skip=True)` (the `/invalidate-cache` endpoint, tmux CLI path) DOES increment `stop_notify_skip_count` and creates delivery state if absent
   - A subsequent `mark_session_idle()` after a `/clear`-endpoint clear fires the stop notification normally (skip_count = 0, not suppressed)

---

## Ticket Classification

**Single ticket.** The fix touches 5 files with targeted, well-understood changes:
- `src/models.py`: add `stop_notify_skip_count: int = 0` to `SessionDeliveryState`
- `src/message_queue.py`: add `last_output` param to `mark_session_idle()` and `_send_stop_notification()`; add skip_count decrement logic
- `src/server.py`: increment `stop_notify_skip_count` in `_invalidate_session_cache()`; pass `last_message` to `mark_session_idle()`
- `src/cli/commands.py`: move `invalidate_cache()` call before tmux operations; distinguish unavailable vs. failed in return-value check
- `tests/regression/test_issue_174_skip_count_race.py` (new): regression test for the late `/clear` Stop hook race scenario

One agent can complete this without context compaction.
