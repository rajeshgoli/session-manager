# Issue #174: Stop Notification Replays Stale Message After Context Clear

**Ticket**: rajeshgoli/session-manager#174
**Status**: Investigation complete, awaiting implementation

---

## Problem Statement

After `sm clear <agent>` + `sm send <agent> "new task" --urgent`, the stop notification sent to the caller contains the agent's **last message from before the clear**, not the response to the new task.

**Observed format:**
```
[sm] agent-name stopped:
<message from task A, before clear>
```

**Expected format:**
```
[sm] agent-name stopped:
<message from task B, the new task>
```

This caused the EM to misread the agent as "still stuck" and clear it mid-work, destroying active context.

---

## Root Cause Analysis

### Background: how stop notifications work

When `sm send ... --urgent` (or any mode with `notify_on_stop=True`) delivers a message:

1. The message is delivered to the target session
2. `state.stop_notify_sender_id = sender_id` is stored in `SessionDeliveryState` (in-memory)
3. When the target's Stop hook fires, `mark_session_idle(session_id)` is called
4. `mark_session_idle()` sees `stop_notify_sender_id` is set and calls `_send_stop_notification()`
5. `_send_stop_notification()` reads `session_manager.hook_output_store.get(session_id)` to get the last output
6. The notification is sent with that output

`hook_output_store` is `app.state.last_claude_output` — a shared dict populated by the Stop hook handler each time a Stop hook fires.

### How `sm clear` resets state (the #167 fix)

`_invalidate_session_cache()` (added for #167) clears:
- `app.state.last_claude_output[session_id]` — removes cached output
- `app.state.pending_stop_notifications` — removes deferred notification flag
- `state.stop_notify_sender_id` — clears any pending notification recipient

`cmd_clear` calls `client.invalidate_cache(session_id)` **after a 2-second sleep** following the tmux `/clear` command.

### The race condition (why #167 fix is incomplete)

`cmd_clear` assumes the Stop hook generated by Claude processing `/clear` arrives at the server **within 2 seconds** of sending Enter. If it does, the sequence is:

```
T=0    Enter sent to Claude via tmux
T~1s   Claude processes /clear, fires Stop hook → HTTP request sent to server
T~1s   Server: last_claude_output[id] = X  (re-reads old transcript, finds task A message)
T~1s   Server: mark_session_idle() → stop_notify_sender_id=None → no notification (correct)
T=3.5s cmd_clear: invalidate_cache() → clears X ✓
T=3.5s cmd_clear returns
T=3.5s+ caller: sm send --urgent → stop_notify_sender_id = EM
T=later task B Stop hook → sends notification with Y ✓
```

**But this fails when the `/clear` Stop hook arrives LATE** — after `invalidate_cache()` has already run AND after `sm send --urgent` has set `stop_notify_sender_id`:

```
T=0    Enter sent to Claude via tmux
T=3.5s cmd_clear: invalidate_cache() → clears X ✓ (stop_notify_sender_id=None at this point)
T=3.5s cmd_clear returns
T=3.5s+ caller: sm send --urgent → stop_notify_sender_id = EM   ← race window opens
T=3.6s  LATE Stop hook from /clear arrives at server:
           read_transcript() → last_message = X   (old transcript still has task A message!)
           last_claude_output[id] = X             ← X re-stored!
           mark_session_idle():
             stop_notify_sender_id = EM           ← set by sm send --urgent
             _send_stop_notification() fires:
               hook_output_store.get(id) = X      ← stale!
               notification: "[sm] agent stopped:\n{X}" → sent to EM  ← BUG
             stop_notify_sender_id = None          ← cleared
T=later task B Stop hook fires:
           stop_notify_sender_id = None            ← already cleared
           No notification sent to EM              ← double failure
```

**The race window exists because the 2-second sleep is not a reliable fence.** The late arrival can be caused by:
- Claude taking > 2s to process `/clear` (e.g., if it was mid-response when ESC was sent)
- FastAPI async task scheduling: the `/clear` Stop hook HTTP request is in-flight concurrently with `invalidate_cache()`; if they race and the Stop hook completes AFTER invalidate, X is re-stored
- Server load causing delayed HTTP request processing

### Why X appears in the notification (not Y or nothing)

After `/clear`, Claude continues to use the **same transcript file** (transcript path does not change). The old file still contains task A's last assistant message. When `read_transcript()` reads that file, it finds X as the latest assistant entry and returns it.

The existing guard at `server.py:1326-1330` prevents falling back to older entries when the newest assistant entry has no text — but when the newest assistant entry IS task A's message (X), it's returned normally.

### Verified against code

- `_send_stop_notification()` at `src/message_queue.py:914-960`: reads `hook_output_store.get(recipient_session_id)` — no guard against stale cache
- `mark_session_idle()` at `src/message_queue.py:262-286`: unconditionally reads and clears `stop_notify_sender_id`
- `cmd_clear` at `src/cli/commands.py:1716`: `client.invalidate_cache()` return value is **not checked** — silent failure is possible
- Stop hook handler at `src/server.py:1349-1365`: updates `last_claude_output` THEN calls `mark_session_idle()` — correct ordering within a single hook, but does not protect against a previous hook's stale content

---

## Proposed Fix

### Core change: pass `last_output` through directly instead of reading from cache

The fundamental problem is that `_send_stop_notification()` reads from a **shared cache** that can hold stale data. The fix is to pass `last_output` directly from the Stop hook handler to `mark_session_idle()` and then to `_send_stop_notification()`.

This eliminates the stale cache read entirely for notification purposes: the notification always uses the output from the **specific Stop hook that triggered it**, not whatever happens to be in the cache.

#### Change 1: `mark_session_idle()` in `src/message_queue.py`

Add `last_output: Optional[str] = None` parameter. Pass it through to `_send_stop_notification()`:

```python
def mark_session_idle(self, session_id: str, last_output: Optional[str] = None):
    state = self._get_or_create_state(session_id)
    state.is_idle = True
    state.last_idle_at = datetime.now()
    logger.info(f"Session {session_id} marked idle")

    if state.stop_notify_sender_id:
        asyncio.create_task(self._send_stop_notification(
            recipient_session_id=session_id,
            sender_session_id=state.stop_notify_sender_id,
            sender_name=state.stop_notify_sender_name,
            last_output=last_output,          # ← pass through directly
        ))
        state.stop_notify_sender_id = None
        state.stop_notify_sender_name = None

    asyncio.create_task(self._try_deliver_messages(session_id))
```

#### Change 2: `_send_stop_notification()` in `src/message_queue.py`

Accept `last_output` as a parameter. Remove the cache read:

```python
async def _send_stop_notification(
    self,
    recipient_session_id: str,
    sender_session_id: str,
    sender_name: Optional[str] = None,
    last_output: Optional[str] = None,   # ← new param, replaces cache read
):
    recipient_session = self.session_manager.get_session(recipient_session_id)
    recipient_name = (
        recipient_session.friendly_name or recipient_session.name or recipient_session_id
        if recipient_session else recipient_session_id
    )

    if last_output:
        truncated = last_output[:500] + "..." if len(last_output) > 500 else last_output
        notification = f"[sm] {recipient_name} stopped:\n{truncated}"
    else:
        notification = f"[sm] {recipient_name} ({recipient_session_id[:8]}) completed (Stop hook fired)"
    ...
```

#### Change 3: Stop hook handler in `src/server.py`

Pass `last_message` to `mark_session_idle()`:

```python
if hook_event == "Stop" and session_manager_id:
    queue_mgr = app.state.session_manager.message_queue_manager if app.state.session_manager else None
    if queue_mgr:
        queue_mgr.mark_session_idle(session_manager_id, last_output=last_message)  # ← pass last_message
        asyncio.create_task(queue_mgr._restore_user_input_after_response(session_manager_id))
```

#### Change 4 (defense-in-depth): check `invalidate_cache` return value in `cmd_clear`

In `src/cli/commands.py`, `cmd_clear` currently ignores the return value:

```python
client.invalidate_cache(target_session_id)
```

Change to log a warning on failure (not a hard error since the tmux clear already happened):

```python
success, unavailable = client.invalidate_cache(target_session_id)
if not success:
    logger.warning(f"Cache invalidation failed for {target_session_id}; stale output may affect next notification")
```

### Why this fix is correct

- **No race**: the notification uses `last_message` read in the **same hook invocation** that triggered it — it cannot be stale from a different invocation
- **The /clear Stop hook no longer contaminates**: even if the /clear Stop hook arrives late and passes `last_message = X`, that X is only used for the notification IF `stop_notify_sender_id` is set at that exact moment AND the stop hook fires for the new task
- **Backward compatible**: `hook_output_store` still updated for `/status` and `sm what` — no change to those flows
- **No schema changes**: no new session state fields, no database changes

### What about the deferred notification case?

When the transcript isn't flushed at Stop hook time (`last_message = None`):
- `mark_session_idle(session_id, last_output=None)` is called
- `_send_stop_notification()` receives `last_output=None` → sends generic "(Stop hook fired)" message
- `stop_notify_sender_id` is cleared

The deferred `idle_prompt` path (`server.py:1570-1595`) does NOT call `mark_session_idle()`, so it does not re-send the stop notification. The EM receives a generic message instead of the full content.

This is acceptable: the deferred case is already a degraded path (transcript not flushed is an edge case), and the generic message is at least correct (not stale). If fuller deferred coverage is needed, that's a separate issue.

---

## Acceptance Criteria

1. **Repro scenario fixed**: After `sm clear` + `sm send --urgent`, the stop notification sent to the EM contains the agent's response to the new task (or the generic "Stop hook fired" message), NOT a message from before the clear
2. **Regression for #167 still passes**: existing tests in `tests/regression/test_issue_167_clear_stale_stop_notification.py` continue to pass
3. **New regression test**: A new test in `tests/regression/` simulates the race: Stop hook fires with stale content AFTER `sm send --urgent` has set `stop_notify_sender_id`. The notification should contain the stale content (since it came from that same hook) — but crucially, a SUBSEQUENT hook with new content should also work correctly

---

## Ticket Classification

**Single ticket.** The fix touches 3 files with targeted, well-understood changes:
- `src/message_queue.py`: add parameter to `mark_session_idle()` and `_send_stop_notification()`
- `src/server.py`: pass `last_message` to `mark_session_idle()`
- `src/cli/commands.py`: check `invalidate_cache()` return value

One agent can complete this without context compaction.
